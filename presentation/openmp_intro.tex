\documentclass[handout]{beamer}
\usecolortheme{beaver}
\setbeamertemplate{navigation symbols}{}
\setbeamercolor{block title}{bg=white!95!black,fg=black}
\defbeamertemplate{description item}{align left}{\insertdescriptionitem\hfill}
    \setbeamertemplate{description item}[align left]
\usepackage{tikz}

\usepackage[outputdir=build]{minted}
\usepackage{tcolorbox}
\tcbuselibrary{minted,skins}

% Patch to fix https://github.com/T-F-S/tcolorbox/issues/12
\makeatletter
\def\tcb@minted@input@listing#1#2#3#4{%
  \edef\temp@a{#4}%
  \ifx\temp@a\@empty%
  \else%
    \toks@=\expandafter{#4}%
    \edef\tcb@temp{\noexpand\usemintedstyle{\the\toks@}}%
    \tcb@temp%
  \fi%
  \toks@=\expandafter{#1}%
  \edef\tcb@temp{\noexpand\inputminted[\the\toks@]}%
  \IfFileExists{\minted@outputdir#3}%
    {\tcb@temp{#2}{\minted@outputdir#3}}%
    {\tcb@temp{#2}{#3}}%
}
\makeatother

\newtcblisting{ccode}[2][]{%
  listing engine=minted,
  minted language=#2,
  minted options={breaklines,breakanywhere,fontsize=\scriptsize,gobble=8},
  listing only,
  before skip=0pt,
  after skip=8pt,
  left skip=0pt,
  right skip=0pt,
  size=fbox,
  sharp corners,
  %colframe=white!75!black,
  colframe=white,
  boxrule=0pt,
  frame hidden,
  #1
}


\newtcbinputlisting[]{\inputcode}[3][]{%
  listing engine=minted,
  minted language=#2,
  minted options={breaklines,breakanywhere,fontsize=\scriptsize,#1},
  listing file={#3},
  listing only,
  size=fbox,
  before skip=0pt,
  after skip=10pt,
  left skip=0pt,
  right skip=0pt,
  sharp corners,
  %colframe=white!75!black,
  colframe=white,
  boxrule=0pt,
  frame hidden
}


\title{Introduction to OpenMP}
\subtitle{Ferienakademie 2017}
\author{Nathan Brei}
\institute{Technical University of Munich}
\date\today

\begin{document}
\begin{frame}
  \titlepage
\end{frame}

\begin{frame}
  \frametitle{Parallelism levels}
  \begin{block}{Distributed-memory parallelism}
    \begin{description}[Disadvantages]
    \item[Description] Isolated processes, often running on different machines, communicate by sending messages.
    \item[Advantages] High scalability
    \item[Disadvantages] Reliability, communication overhead
    \item[Examples] MPI, Hadoop, Spark. Akka, Erlang. 
    \end{description}
  \end{block}
  \begin{block}{Shared-memory thread-level parallelism}
    \begin{description}[Disadvantages]
    \item[Description] Multiple threads on the same machine. Each thread has its own isolated register space, but they share a memory address space.
    \item[Advantages] Parallelizing existing code, memory-bound problems
    \item[Disadvantages] Contains subtleties
    \item[Examples] Pthreads, Java threads, OpenMP
    \end{description}
  \end{block}
\end{frame}

\begin{frame}
  \frametitle{Parallelism levels}
  \begin{block}{Instruction-level parallelism}
    \begin{description}[Disadvantages]
    \item[Description] Each CPU core maximizes instruction throughput by pipelining, parallelizing execution units and registers, etc. Shared registers, shared memory.
    \item[Advantages] Vectorize innermost compute kernels, use memory hierarchy efficiently
    \item[Disadvantages] Limited scalability, absurdly low-level
    \item[Examples] Assembly language, \texttt{\#pragma simd}, choosing block sizes very carefully
    \end{description}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Launching a team of threads --- Parallel Regions}
  \begin{columns}[t]%[onlytextwidth]
    \begin{column}{0.65\textwidth}
      \inputcode[]{c}{src/ex1.c}
    \end{column}
    \pause
    \begin{column}{0.4\textwidth}
      \inputcode[]{text}{output/ex1.txt}
      \begin{ccode}[]
        {text}
        About to fork...
        Hello from thread 2 of 3
        Hello from thread 0 of 3
        Hello from thread 1 of 3
        ...Rejoined.
      \end{ccode}
    \end{column}
  \end{columns}
  \pause
  \begin{itemize}
  \item \emph{Fork-join execution model}
  \item Print statements are interleaved nondeterministically
  \item Number of threads is chosen automatically, or specified by \mintinline{text}{$OMP_NUM_THREADS}, \mintinline{c}{omp_set_num_threads(int t)}, \mintinline{c}{#pragma omp parallel num_threads(2)}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Assigning code blocks to threads --- Parallel Sections}
  \begin{columns}[t]%[onlytextwidth]
    \begin{column}{0.65\textwidth}
      \inputcode[]{c}{src/ex2.c}
    \end{column}
    \pause
    \begin{column}{0.4\textwidth}
      \begin{ccode}[]
        {text}
        Thread 0, iter 0
        Thread 0, iter 1
          Thread 1, iter 0
        Thread 0, iter 2
          Thread 1, iter 1
          Thread 1, iter 2
          Thread 1, iter 3
        Thread 0, iter 3\end{ccode}
      \inputcode[]{text}{output/ex2.txt}
    \end{column}
  \end{columns}
  \pause
  \begin{itemize}
  \item Number of parallel sections is fixed at compile time.
  \item No guarantee how statements get interleaved, or how many threads are actually used!
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Problem: Race conditions}
  Definition: A class of bug where the program's output depends on the timing of events which are not under the programmer's control.  
  \begin{columns}[t]%[onlytextwidth]
    \begin{column}{0.5\textwidth}
      \begin{ccode}[]{c}
        int a = 0;
        int b = 0;
        #pragma omp parallel sections
        {
          #pragma omp section
          a = 1;

          #pragma omp section
          b = a;
        }
        printf("b = %d\n", b);\end{ccode}
    \end{column}
    \pause
    \begin{column}{0.3\textwidth}
      \begin{ccode}[]
        {text}
        a = 0
        b = 0
        a = 1
        b = a
          ==> (b == 1)\end{ccode}
      \begin{ccode}[]
        {text}
        a = 0
        b = 0
        b = a
        a = 1
          ==> (b == 0)\end{ccode}
    \end{column}
  \end{columns}
  \pause
  \begin{itemize}
  \item For simple programs, the output often \emph{appears} deterministic.
  \item However, instruction interleaving is \emph{not} defined by OpenMP.
  \item It depends on the CPU architecture, operating system, system load, compiler, and code optimization level.
  \item Race conditions often lie dormant only to materialize when you least want them to.
  \end{itemize}

\end{frame}



\begin{frame}[fragile]
  \frametitle{Problem: Race conditions}
  Some race conditions are not obvious from the C code, but emerge when compiled to assembly/microcode. \emph{Every} variable access in C requires memory \texttt{load} or \texttt{store} operations unless the compiler can prove otherwise. 
  
  \begin{columns}[t]%[onlytextwidth]
    \begin{column}{0.43\textwidth}
      \inputcode[firstline=5,lastline=22,gobble=2]{c}{src/ex4.c}
    \end{column}

    \begin{column}{0.43\textwidth}
      \inputcode[firstline=5,lastline=22,gobble=2]{c}{src/ex5.c}
    \end{column}
    
    \begin{column}{0.3\textwidth}
      \begin{ccode}[after skip=4pt]
        {text}
        load (total) -> a
          load (total) -> c
        add 1, a -> b
          add 2, c -> d
        store b -> (total)
          store d -> (total)

          ==> (total == 2)\end{ccode}
      \begin{ccode}[]
        {text}
        load (total) -> a
        add 1, a -> b
          load (total) -> c
          add 2, c -> d
          store d -> (total)
        store b -> (total)
        
          ==> (total == 1)\end{ccode}
    \end{column}
  \end{columns}
\end{frame}



\begin{frame}[fragile]
  \frametitle{Privatizing intermediate variables}
  \begin{columns}[t]%[onlytextwidth]
    \begin{column}{0.6\textwidth}
      \inputcode[firstline=8,lastline=32,gobble=2]{c}{src/ex6.c}
    \end{column}

    \pause
    \begin{column}{0.4\textwidth}
      \inputcode[]{text}{output/ex6.txt}
      Problem: Compiler treats variables as shared by default! Reusing variable names creates unnecessary data hazards.
    \end{column}
  \end{columns}
\end{frame}


\begin{frame}[fragile]
  \frametitle{Privatizing intermediate variables}
  \begin{columns}[t]%[onlytextwidth]
    \begin{column}{0.6\textwidth}
      \inputcode[firstline=8,lastline=32,gobble=2]{c}{src/ex7.c}
    \end{column}
    \begin{column}{0.4\textwidth}
      \inputcode[]{text}{output/ex7.txt}
      Distinguish between variables which \emph{must} be shared and those which should be scoped local to a thread. Use \texttt{firstprivate, lastprivate} to share with enclosing scope. 
    \end{column}
  \end{columns}
\end{frame}


\begin{frame}[fragile]
  \frametitle{Protecting shared resources -- Critical and Atomic Sections}
  \begin{columns}[t]
    \begin{column}{0.7\textwidth}
      \inputcode[firstline=6,lastline=28,gobble=2]{c}{src/ex8.c}
    \end{column}
    \begin{column}{0.4\textwidth}
      \inputcode[]{text}{output/ex8.txt}
      Mark a code block for mutually exclusive access. This protects a (possibly named) resource using a lock. Long critical regions hurt scalability (see Amdahl's Law). For operations like \texttt{+=}, use \texttt{\#pragma omp atomic}, which protects the loads/stores at the instruction level.
      
    \end{column}
  \end{columns}
\end{frame}


\begin{frame}[fragile]
  \frametitle{Enforcing an ordering between threads --- Barriers}
  \begin{columns}[t]%[onlytextwidth]
    \begin{column}{0.65\textwidth}
      \inputcode[firstline=7,lastline=27,gobble=2]{c}{src/ex10.c}
    \end{column}
    \begin{column}{0.4\textwidth}
      Consider your bank account! In September, your HiWi pays 500EUR and you withdraw 50EUR from your local ATM. At the end of the month, your bank credits 1\% interest. Early October, you withdraw another 50EUR from an ATM in Bozen to pay for vouchers. Your bank has one thread updating account balances and another processing interbank transfers.
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Enforcing an ordering between threads --- Barriers}
  \begin{columns}[t]%[onlytextwidth]
    \begin{column}{0.65\textwidth}
      \inputcode[firstline=7,lastline=27,gobble=2]{c}{src/ex11.c}
    \end{column}
    \pause
    \begin{column}{0.4\textwidth}
      \begin{block}{Definition}
      A point in the execution of a program encountered by a team of threads, beyond which no thread in the team may execute until all threads in the team have reached the barrier and all explicit tasks generated by the team have executed to completion. 
      \end{block}
    \end{column}
  \end{columns}
\end{frame}


\begin{frame}[fragile]
  \frametitle{Dependency Graphs}
  \begin{columns}[t]%[onlytextwidth]
    \begin{column}{0.65\textwidth}
      \inputcode[]{c}{src/ex1.c}
    \end{column}
    \pause
    \begin{column}{0.4\textwidth}
      \inputcode[]{text}{output/ex1.txt}
      \begin{ccode}[]
        {c}
        Another example
        Yet another example
        PENIS
        PENIS
      \end{ccode}
    \end{column}
  \end{columns}
  \pause
  \begin{itemize}
  \item Print statements are interleaved nondeterministically
  \end{itemize}
\end{frame}



\begin{frame}[fragile]
  \frametitle{Parallelizing For Loops}
  For numerical code, most of the computation usually happens inside an inner loop, and we wish to distribute the work evenly across an arbitrary number of threads determined at runtime.
  \begin{columns}[t]%[onlytextwidth]
    \begin{column}{0.65\textwidth}
      \inputcode[]{c}{src/exfor.c}
    \end{column}
    \pause
    \begin{column}{0.4\textwidth}
      \inputcode[]{text}{output/exfor.txt}
    \end{column}
  \end{columns}
  \pause
  \begin{itemize}
  \item Available scheduling strategies: static, dynamic, guided
  \item Adjust chunk size in order to increase the parallelism granularity
  \item  
  \end{itemize}
\end{frame}



\begin{frame}[fragile]
  \frametitle{Loop-Carried Dependencies}
  \begin{columns}[t]%[onlytextwidth]
    \begin{column}{0.65\textwidth}
      \inputcode[]{c}{src/ex1.c}
    \end{column}
    \pause
    \begin{column}{0.4\textwidth}
      \inputcode[]{text}{output/ex1.txt}
      \begin{ccode}[]
        {c}
        Another example
        Yet another example
        PENIS

      \end{ccode}
    \end{column}
  \end{columns}
  \pause
  \begin{itemize}
  \item Heuristic: Array accesses such as \texttt{A[i]} are good, \texttt{A[i-1]} are bad
  \item Remove dependencies via loop splitting, alignment, interchange
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Putting everything together: Sum all elements in array}
  \begin{columns}[t]%[onlytextwidth]
    \begin{column}{0.65\textwidth}
      \inputcode[]{c}{src/ex1.c}
    \end{column}
    \pause
    \begin{column}{0.4\textwidth}
      \inputcode[]{text}{output/ex1.txt}
      \begin{ccode}[]
        {c}
        Another example
        Yet another example
        PENIS
        PENIS
      \end{ccode}
    \end{column}
  \end{columns}
  \pause
  \begin{itemize}
  \item Heuristic: Array accesses such as \texttt{A[i]} are good, \texttt{A[i-1]} are bad
  \item Remove dependencies via loop splitting, alignment, interchange
  \end{itemize}
\end{frame}
\end{document}
